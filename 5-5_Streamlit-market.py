"""
ðŸ“Š HDB Market Segmentation Dashboard (Precomputed)
---------------------------------------------------

Summary:
This Streamlit app visualizes precomputed HDB market segmentation results.  
It uses a preprocessed dataset generated by a trained hybrid pipeline (UMAP + KMeans) and allows interactive exploration of property characteristics across towns, flat types, and age groups.  

Key Features:
1. Loads precomputed segmentation data with cluster assignments (MARKET_SEGMENT).  
2. Provides interactive filters:
   - Towns
   - Flat Types
   - Age Groups
   - Price Range
   - Floor Area Range
3. Displays summary metrics for the filtered dataset:
   - Total properties
   - Average resale price
   - Number of towns and flat types analyzed
4. Interactive visualizations:
   - Flat Age Distribution by Town (stacked bar chart)
   - Flat Type Distribution by Town (stacked bar chart)
   - Mean Price Heatmap (Town vs Flat Type) with toggle between resale price and price per sqm
   - Resale Price Trend Over Time
5. Market Segment Summary Table:
   - Mean/Median price, count of properties, average floor area, and average age per segment

Prerequisites:
- Python 3.9+ (recommended)
- Install required packages:
    pip install streamlit pandas plotly numpy scikit-learn

- Required input file:
    â€¢ 5-4_precomputed_market.pkl â†’ Precomputed dataset containing MARKET_SEGMENT assignments, UMAP embeddings, and selected features

Usage:
    Run the app locally with:
        streamlit run market_segmentation_app.py
    (replace `market_segmentation_app.py` with your filename)

Notes:
- AGE_GROUP is computed dynamically from the AGE column:
    â€¢ New(Below 5yrs), Moderate(5-14yrs), Old(15-29yrs), Very Old(Above 30yrs)
- Only properties matching the sidebar filters are used for visualizations and metrics.
- Precomputed data ensures fast performance by avoiding real-time clustering computation.
"""


import streamlit as st 
import pandas as pd
import pickle
import plotly.graph_objs as go
import plotly.express as px
import warnings

warnings.filterwarnings('ignore')

# ====================
# Streamlit Page Config
# ====================
hide_streamlit_style = """
    <style>
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
    </style>
"""
st.markdown(hide_streamlit_style, unsafe_allow_html=True)

st.set_page_config(
    page_title="HDB Market Segmentation (Precomputed)", 
    page_icon="ðŸ“Š", 
    layout="wide",
    initial_sidebar_state="expanded"
)

# ====================
# Helpers
# ====================
def format_to_k(price):
    """Formats a numeric price value to a string like '$349K'."""
    if pd.isna(price) or price == 0:
        return "$0K"
    return f"${price/1000:.0f}K"

# ====================
# Load Precomputed Data
# ====================
@st.cache_data
def load_precomputed():
    try:
        with open("5-4_precomputed_market.pkl", "rb") as f:
            data = pickle.load(f)
        df = data["df_segmented"]   # full dataset with MARKET_SEGMENT already assigned
        st.success(f"âœ… Loaded precomputed pipeline: {len(df)} rows, {len(df.columns)} columns")
        return df
    except FileNotFoundError:
        st.error("âŒ File not found: precomputed_market_pipeline.pkl")
        return None
    except Exception as e:
        st.error(f"âŒ Error loading precomputed data: {str(e)}")
        st.exception(e)
        return None

# ====================
# Visualization Functions
# ====================
def create_flat_age_distribution(df, selected_towns=None):
    if selected_towns:
        df_filtered = df[df['TOWN'].isin(selected_towns)]
    else:
        df_filtered = df.copy()
    age_group_counts = df_filtered.groupby(['TOWN', 'AGE_GROUP']).size().unstack(fill_value=0)
    age_colors = {
        'New(Below 5yrs)': '#A6CEE3',
        'Moderate(5-14yrs)': '#1F78B4',
        'Old(15-29yrs)': '#FDBF6F',
        'Very Old(Above 30yrs)': '#F4A6A6'
    }
    fig = go.Figure()
    for group in age_group_counts.columns:
        fig.add_trace(go.Bar(
            name=group,
            x=age_group_counts.index,
            y=age_group_counts[group],
            marker_color=age_colors.get(group, '#808080')
        ))
    fig.update_layout(
        title="Flat Age Distribution by Town",
        xaxis_title="Town",
        yaxis_title="Number of Flats",
        barmode='stack',
        height=500,
        showlegend=True
    )
    return fig

def create_price_timeline(df, selected_towns=None, selected_flat_types=None):
    if selected_towns:
        df = df[df['TOWN'].isin(selected_towns)]
    if selected_flat_types:
        df = df[df['FLAT_TYPE'].isin(selected_flat_types)]
    timeline_data = df.groupby('DATE')['RESALE_PRICE'].agg(['mean', 'count']).reset_index()
    timeline_data = timeline_data[timeline_data['count'] >= 5]
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=timeline_data['DATE'],
        y=timeline_data['mean'],
        mode='lines+markers',
        name='Mean Resale Price',
        line=dict(color='#1f77b4', width=2),
        marker=dict(size=4)
    ))
    fig.update_layout(
        title="Resale Price Trend Over Time",
        xaxis_title="Date",
        yaxis_title="Mean Resale Price (SGD)",
        height=400
    )
    return fig

def create_flat_type_distribution(df, selected_towns=None):
    if selected_towns:
        df_filtered = df[df['TOWN'].isin(selected_towns)]
    else:
        df_filtered = df
    flat_type_counts = df_filtered.groupby(['TOWN', 'FLAT_TYPE']).size().unstack(fill_value=0)
    flat_type_colors = {
        '3 ROOM': '#B3CDE3',
        '4 ROOM': '#6497B1',
        '5 ROOM': '#FFA07A',
        'EXECUTIVE': '#CD5C5C'
    }
    fig = go.Figure()
    for flat_type in flat_type_counts.columns:
        fig.add_trace(go.Bar(
            name=flat_type,
            x=flat_type_counts.index,
            y=flat_type_counts[flat_type],
            marker_color=flat_type_colors.get(flat_type, '#808080')
        ))
    fig.update_layout(
        title="Flat Type Distribution by Town",
        xaxis_title="Town",
        yaxis_title="Number of Properties",
        barmode='stack',
        height=500,
        showlegend=True
    )
    return fig

def create_price_heatmap(df, selected_towns=None, selected_flat_types=None):
    if selected_towns:
        df = df[df['TOWN'].isin(selected_towns)]
    if selected_flat_types:
        df = df[df['FLAT_TYPE'].isin(selected_flat_types)]
    resale_data = df.groupby(['TOWN', 'FLAT_TYPE'])['RESALE_PRICE'].mean().unstack(fill_value=0) / 1000
    sqm_data = df.groupby(['TOWN', 'FLAT_TYPE'])['PRICE_PER_SQM'].mean().unstack(fill_value=0)
    custom_colorscale = [[0.0, "#e6f2ff"], [1.0, "#003366"]]
    fig = go.Figure()
    fig.add_trace(go.Heatmap(
        z=resale_data.values,
        x=resale_data.columns,
        y=resale_data.index,
        colorscale=custom_colorscale,
        text=resale_data.round(0).astype(int),
        texttemplate="%{text}K",
        textfont={"size": 10},
        colorbar=dict(title="Price (SGD K)"),
        visible=True,
        name="Resale Price"
    ))
    fig.add_trace(go.Heatmap(
        z=sqm_data.values,
        x=sqm_data.columns,
        y=sqm_data.index,
        colorscale=custom_colorscale,
        text=sqm_data.round(0).astype(int),
        texttemplate="%{text}",
        textfont={"size": 10},
        colorbar=dict(title="Price per sqm (SGD)"),
        visible=False,
        name="Price per sqm"
    ))
    fig.update_layout(
        title="Mean Price Heatmap (Town vs Flat Type)",
        xaxis_title="Flat Type",
        yaxis_title="Town",
        height=600,
        updatemenus=[dict(
            buttons=[
                dict(label="Resale Price (K SGD)", method="update", args=[{"visible": [True, False]}, {"title": "Mean Resale Price Heatmap"}]),
                dict(label="Price per sqm (SGD)", method="update", args=[{"visible": [False, True]}, {"title": "Mean Price per sqm Heatmap"}])
            ],
            direction="down",
            showactive=True,
            x=1.0, xanchor="right", y=1.15, yanchor="top"
        )]
    )
    return fig

def create_price_boxplot(df, selected_flat_types=None):
    if selected_flat_types:
        df = df[df['FLAT_TYPE'].isin(selected_flat_types)]

    # Define custom flat type order
    flat_type_order = ['3 ROOM', '4 ROOM', '5 ROOM', 'EXECUTIVE']
    df['FLAT_TYPE'] = pd.Categorical(df['FLAT_TYPE'], categories=flat_type_order, ordered=True)

    fig = px.box(
        df,
        x="TOWN",
        y="RESALE_PRICE",
        color="FLAT_TYPE",
        category_orders={"FLAT_TYPE": flat_type_order},
        title="Resale Price Distribution by Town and Flat Type",
        labels={"RESALE_PRICE": "Resale Price (SGD)", "TOWN": "Town"},
        height=500
    )
    fig.update_layout(
        boxmode='group',
        xaxis_tickangle=-45,
        showlegend=True
    )
    return fig
    
# ====================
# Main App
# ====================
def main():
    st.title("ðŸ“Š Market Segmentation")
    df = load_precomputed()
    if df is None:
        return

    def assign_age_group(age):
        if age < 5:
            return 'New(Below 5yrs)'
        elif age < 15:
            return 'Moderate(5-14yrs)'
        elif age < 30:
            return 'Old(15-29yrs)'
        else:
            return 'Very Old(Above 30yrs)'

    df['AGE_GROUP'] = df['AGE'].apply(assign_age_group)

 #   st.write("**Sample Data:**")
 #   st.dataframe(df.head())

    # Sidebar filters
    st.sidebar.header("ðŸ”§ Analysis Filters")
    available_towns = sorted(df['TOWN'].unique())
    available_flat_types = sorted(df['FLAT_TYPE'].unique())
    available_age_groups = sorted(df['AGE_GROUP'].unique())

    # Town and Flat Type Filters
    selected_towns = st.sidebar.multiselect("Select Towns:", available_towns, default=available_towns[:5])
    selected_flat_types = st.sidebar.multiselect("Select Flat Types:", available_flat_types, default=available_flat_types)
    selected_age_groups = st.sidebar.multiselect("Select Age Groups:", available_age_groups, default=available_age_groups)

    # Price Range Filter
    min_price, max_price = int(df['RESALE_PRICE'].min()), int(df['RESALE_PRICE'].max())
    price_range = st.sidebar.slider("Select Price Range (SGD):", min_price, max_price, (min_price, max_price), step=1000)

    # Floor Area Filter
    min_area, max_area = int(df['FLOOR_AREA_SQM'].min()), int(df['FLOOR_AREA_SQM'].max())
    area_range = st.sidebar.slider("Select Floor Area Range (sqm):", min_area, max_area, (min_area, max_area), step=5)

    # Apply filters
    df_filtered = df[
        (df['TOWN'].isin(selected_towns)) &
        (df['FLAT_TYPE'].isin(selected_flat_types)) &
        (df['AGE_GROUP'].isin(selected_age_groups)) &
        (df['RESALE_PRICE'].between(price_range[0], price_range[1])) &
        (df['FLOOR_AREA_SQM'].between(area_range[0], area_range[1]))
    ]


    # Overview metrics
    st.subheader("ðŸ“ˆ Market Overview")
    col1, col2, col3, col4 = st.columns(4)
    with col1: st.metric("Total Properties", f"{len(df_filtered):,}")
    with col2: st.metric("Avg Price", format_to_k(df_filtered['RESALE_PRICE'].mean()))
    with col3: st.metric("Towns Analyzed", len(selected_towns))
    with col4: st.metric("Flat Types", len(selected_flat_types))

    # Charts
    st.markdown("---")
    col1, col2 = st.columns(2)
    st.subheader("ðŸ“Š Price Distribution by Town and Flat Type");st.plotly_chart(create_price_boxplot(df_filtered, selected_flat_types), use_container_width=True)
    with col1: st.subheader("ðŸ’° Flat Age Distribution"); st.plotly_chart(create_flat_age_distribution(df_filtered, selected_towns), use_container_width=True)
    with col2: st.subheader("ðŸ  Flat Type Distribution"); st.plotly_chart(create_flat_type_distribution(df_filtered, selected_towns), use_container_width=True)
    st.subheader("ðŸŒ¡ï¸ Price Heatmap"); st.plotly_chart(create_price_heatmap(df_filtered, selected_towns, selected_flat_types), use_container_width=True)
    st.subheader("ðŸ“ˆ Price Trend Over Time"); st.plotly_chart(create_price_timeline(df_filtered, selected_towns, selected_flat_types), use_container_width=True)

    # Segment summary
    if 'MARKET_SEGMENT' in df_filtered.columns:
        st.markdown("---")
        st.subheader("ðŸŽ¯ Market Segments Analysis")
        segment_summary = df_filtered.groupby('MARKET_SEGMENT').agg({
            'RESALE_PRICE': ['mean', 'median', 'count'],
            'FLOOR_AREA_SQM': 'mean',
            'AGE': 'mean'
        }).round(2)
        segment_summary.columns = ['Mean_Price', 'Median_Price', 'Count', 'Avg_Area', 'Avg_Age']
        segment_summary = segment_summary.reset_index()
        segment_summary['Mean_Price_K'] = segment_summary['Mean_Price'].apply(format_to_k)
        segment_summary['Median_Price_K'] = segment_summary['Median_Price'].apply(format_to_k)
        st.dataframe(segment_summary[['MARKET_SEGMENT','Count','Mean_Price_K','Median_Price_K','Avg_Area','Avg_Age']], use_container_width=True)

if __name__ == "__main__":
    main()
